<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BRADMAN ‚Äì The Infinite Chase</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
  <style>
    /* ---------------------------------------------------------------------- */
    /* BASE TEMPLATE STYLES - MAINTAINED FROM SPACERUN3008 */
    /* ---------------------------------------------------------------------- */
    body {
      margin: 0;
      /* Use the specified background image */
      background: url('bgobe.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: 'Orbitron', sans-serif;
      color: white;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    #main-content {
      width: 100%;
    }
    /* The h1 is removed, but we keep the canvas styles */
    canvas {
      width: 90vmin;
      height: 90vmin;
      max-width: 90vw;
      max-height: 90vw;
      /* Use the specified canvas background GIF */
      background: url('moshed-2021-11-29-0-39-58.gif') center/cover no-repeat;
      display: block;
      box-shadow: 0 0 20px #ffff00; /* Bradman Yellow for the glow */
      margin: 0.2rem auto 0.5rem auto; /* REDUCED MARGINS FOR BETTER SCREEN FIT */
      outline: none;
      position: relative;
      z-index: 1;
      image-rendering: crisp-edges;
      image-rendering: -webkit-optimize-contrast;
    }
    /* Status bar split for touch */
    #statusBarRow1,
    #statusBarRow2 {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.7em;
      flex-wrap: nowrap;
      overflow-x: auto;
      white-space: nowrap;
      width: 100%;
      padding: 0 5px; /* Add padding to prevent horizontal scroll issues */
    }
    #statusBarRow1 {
      font-size: 1.1rem;
      margin-bottom: 0.15em;
    }
    #statusBarRow2 {
      font-size: 1.1rem;
      margin-bottom: 0.6em;
    }
    /* Desktop default: show combined bar, hide split bars */
    #statusBarCombined {
      display: flex;
      font-size: 1rem;
      color: white;
      margin-bottom: 0.7em;
      z-index: 3;
      justify-content: center;
      align-items: center;
      gap: 0.7em;
      flex-wrap: nowrap;
      overflow-x: auto;
      white-space: nowrap;
      width: 100%;
      padding: 0 5px; /* Add padding to prevent horizontal scroll issues */
    }
    .show-dpad #statusBarCombined { display: none; }
    .show-dpad #statusBarRow1, .show-dpad #statusBarRow2 { display: flex; }
    #statusBarRow1, #statusBarRow2 { display: none; }
    /* Buttons and text styles (shared for both modes) */
    #statusBarCombined span, #statusBarRow1 span, #statusBarRow2 span {
      font-size: 1.1rem;
      margin: 0 0.6em;
      white-space: nowrap;
    }
    /* BRADMAN SPECIFIC UI COLORS */
    #levelDisplay, #levelDisplayTouch {
        color: #00ff00; /* Level green */
        font-weight: bold;
    }
    #highScoreDisplay,
    #highScoreDisplayTouch {
      color: #a0ffd0;
    }
    #statusBarCombined button, #statusBarRow1 button, #statusBarRow2 button,
    #statusBarCombined select, #statusBarRow1 select, #statusBarRow2 select {
      background: none;
      font-size: 1rem;
      font-family: 'Orbitron', sans-serif;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      animation: pulse 1.5s infinite ease-in-out; 
      margin: 0 0.3rem;
      outline: none;
    }
    #statusBarCombined select, #statusBarRow2 select {
      background: #181818;
      color: white;
      border-radius: 6px;
      border: 1px solid #ffff00; /* Bradman Yellow border */
      padding: 0.1rem 0.5rem;
      font-family: 'Orbitron', sans-serif;
      margin-left: 0.5rem;
      font-size: 1rem;
      outline: none;
      cursor: pointer;
    }
    a.leaderboard-link {
      color: white;
      text-decoration: underline;
      font-size: 1rem;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.1; }
      100% { opacity: 1; }
    }
    #gameStatusLine {
      display: none;
      margin-top: 0.5rem;
      font-size: 1rem;
      color: white;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      z-index: 4;
      position: relative;
    }
    #finalScore {
      margin: 0 0.3rem;
      color: white;
    }
    #loginPopup {
      display: none;
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      border: 1px solid #888;
      padding: 1rem;
      border-radius: 10px;
      color: white;
      z-index: 20;
      min-width: 250px;
    }
    #loginPopup button {
      margin: 0.5rem;
      font-size: 1rem;
      background: #333;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
    }
    #closeLoginPopup {
      position: absolute;
      top: 5px;
      right: 5px;
      font-size: 18px;
      color: white;
      cursor: pointer;
    }
    #overlay {
      display: none;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 16px;
      font-size: 2rem;
      z-index: 5;
      padding: 2rem 3rem;
      pointer-events: none;
    }
    /* D-pad grid - only on touch devices */
    #dpad-area {
      display: none;
      width: 100%;
      justify-content: center;
      align-items: center;
      margin: 0.5em 0 0.2em 0; /* Adjusted margins */
    }
    .show-dpad #dpad-area {
      display: flex;
    }
    #dpad-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 1.1em;
    }
    .dpad-btn {
      width: 94px;
      height: 94px;
      background: rgba(32,32,32,0.7);
      border: 3px solid #ffff00; /* Bradman Yellow */
      color: #fff;
      font-size: 2.7rem;
      border-radius: 24px;
      cursor: pointer;
      box-shadow: 0 0 18px #ffff0080;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      touch-action: manipulation;
      transition: background 0.15s, border 0.15s;
      opacity: 0.97;
      outline: none;
      backdrop-filter: blur(2px);
    }
    .dpad-btn:active {
      background: #ffff00cc; /* Yellow active color */
      border: 3px solid #fff;
      opacity: 1;
    }
    @media (max-width: 650px) {
      .dpad-btn {
        width: 64px;
        height: 64px;
        font-size: 1.52rem;
      }
      #dpad-area { margin: 0.2em 0 0.1em 0; }
      #statusBarCombined, #statusBarRow1, #statusBarRow2 { font-size: 1.0rem; }
    }
    .visually-hidden {
      position: absolute !important;
      height: 1px; width: 1px;
      overflow: hidden;
      clip: rect(1px 1px 1px 1px);
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap;
    }
  </style>
</head>
<body>
<div id="main-content">
  <div style="position:relative;">
    <canvas id="gameCanvas" tabindex="0" aria-label="Bradman Pac-Man inspired game"></canvas>
    <div id="overlay"></div>
  </div>
  
  <div id="statusBarCombined">
    <span id="scoreDisplay">Score: 0</span>
    <span id="levelDisplay">Level: 1</span>
    <span id="highScoreDisplay">High Score: 0</span>
    <button id="pauseBtn" aria-pressed="false" title="Pause/Resume">‚è∏Ô∏è</button>
    <button id="muteBtn" aria-pressed="false" title="Mute/Unmute SFX">üîä</button>
    <label for="speedSelect" class="visually-hidden">Game Speed</label>
    <select id="speedSelect" title="Game Speed">
      <option value="250">Normal</option>
      <option value="120">Fast</option>
      <option value="60">Turbo</option>
    </select>
    <button id="toggleRadio" aria-pressed="false">Radio ON</button>
    <button id="loginBtn">LOG IN</button>
  </div>
  <div id="statusBarRow1">
    <span id="scoreDisplayTouch">Score: 0</span>
    <span id="levelDisplayTouch">Level: 1</span>
    <button id="pauseBtnTouch" aria-pressed="false" title="Pause/Resume">‚è∏Ô∏è</button>
  </div>
  <div id="statusBarRow2">
    <button id="muteBtnTouch" aria-pressed="false" title="Mute/Unmute SFX">üîä</button>
    <label for="speedSelectTouch" class="visually-hidden">Game Speed</label>
    <select id="speedSelectTouch" title="Game Speed">
      <option value="250">Normal</option>
      <option value="120">Fast</option>
      <option value="60">Turbo</option>
    </select>
    <button id="toggleRadioTouch" aria-pressed="false">Radio ON</button>
    <button id="loginBtnTouch">LOG IN</button>
  </div>
  <div id="gameStatusLine" aria-live="polite">
    <span>Game over.</span>
    <span id="finalScore">Score: 0</span>
    <button id="restartBtn">Play Again</button>
    <a href="https://games4punks.github.io/spacerun3008/leaderboard.html" class="leaderboard-link" target="_blank" rel="noopener noreferrer">View Leaderboard</a>
  </div>
  <div id="loginPopup" aria-modal="true" role="dialog">
    <span id="closeLoginPopup" tabindex="0" aria-label="Close login popup">&times;</span>
    <p>Select WAX Wallet</p>
    <button onclick="alert('Login with Anchor')">Anchor</button>
    <button onclick="alert('Login with MyCloud')">MyCloud</button>
    <button onclick="alert('Login with Wombat')">Wombat</button>
  </div>
  <div id="dpad-area">
    <div id="dpad-grid">
      <button id="leftBtn"  class="dpad-btn" aria-label="Move Left">‚Üê</button>
      <button id="upBtn"    class="dpad-btn" aria-label="Move Up">‚Üë</button>
      <button id="rightBtn" class="dpad-btn" aria-label="Move Right">‚Üí</button>
      <button id="downBtn"  class="dpad-btn" aria-label="Move Down">‚Üì</button>
    </div>
  </div>
</div>
<audio id="radioStream" loop>
  <source src="http://stream.radiojar.com/2qm1fc5kb" type="audio/mpeg">
</audio>
<audio id="explosionSound" src="explosion.mp3"></audio>
<audio id="crashSound" src="crash.mp3"></audio>
<audio id="spaceshipSound" src="spaceship.mp3"></audio>
<audio id="alienSound" src="alien.mp3"></audio>
<audio id="rocketSound" src="rocket.mp3"></audio>
<audio id="satelliteSound" src="satellite.mp3"></audio>
<audio id="spacemanSound" src="spaceman.mp3"></audio>

<script>
window.onload = function() {
  function isTouchDevice() {
    return (
      'ontouchstart' in window ||
      (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
      (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 0)
    );
  }
  
  // --- Game Constants & Emojis ---
  const BRADMAN_EMOJI = 'üü°';
  const GHOST_EMOJIS = ['üëª', 'üòà', 'üëΩ'];
  const DOT_EMOJI = '‚≠ê';
  const WALL_EMOJI = '‚¨õÔ∏è'; // Black square for walls
  const TILE_SIZE = 20; 
  const GRID_COLS = 30;
  const GRID_ROWS = 30;
  // Dot is removed if >= 5 surrounding walls (max 8 possible)
  const WALL_SURROUND_THRESHOLD = 5; 
  // Wall segment is converted to path if it has 3 or fewer wall neighbors
  const WALL_CLEANUP_THRESHOLD = 3; 

  // --- HTML Elements & Setup (Skipping repeated UI logic) ---
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = GRID_COLS * TILE_SIZE;
  canvas.height = GRID_ROWS * TILE_SIZE;

  const gameStatusLine = document.getElementById("gameStatusLine");
  const finalScoreSpan = document.getElementById("finalScore");
  const radio = document.getElementById("radioStream");
  const overlay = document.getElementById("overlay");
  const loginPopup = document.getElementById("loginPopup");
  const crashSound = document.getElementById("crashSound");
  
  // Set up touch/desktop UI visibility
  const statusBarCombined = document.getElementById("statusBarCombined");
  const statusBarRow1 = document.getElementById("statusBarRow1");
  const statusBarRow2 = document.getElementById("statusBarRow2");
  if (isTouchDevice()) {
    document.body.classList.add('show-dpad');
    statusBarCombined.style.display = "none";
    statusBarRow1.style.display = "flex";
    statusBarRow2.style.display = "flex";
  } else {
    statusBarCombined.style.display = "flex";
    statusBarRow1.style.display = "none";
    statusBarRow2.style.display = "none";
  }

  // Helper to get the correct UI element (touch or desktop version)
  function getEl(id) {
    if (isTouchDevice()) {
      switch (id) {
        case "scoreDisplay": return document.getElementById("scoreDisplayTouch");
        case "levelDisplay": return document.getElementById("levelDisplayTouch");
        case "highScoreDisplay": return document.getElementById("highScoreDisplayTouch");
        case "pauseBtn": return document.getElementById("pauseBtnTouch");
        case "muteBtn": return document.getElementById("muteBtnTouch");
        case "speedSelect": return document.getElementById("speedSelectTouch");
        case "toggleRadio": return document.getElementById("toggleRadioTouch");
        case "loginBtn": return document.getElementById("loginBtnTouch");
      }
    }
    return document.getElementById(id);
  }

  // --- Game State ---
  let level = 1;
  let score = 0;
  let highScore = Number(localStorage.getItem('bradman_highscore') || "0");
  let bradman = { x: 1, y: 1, dx: 0, dy: 0, next_dx: 0, next_dy: 0 }; 
  let ghosts = [];
  let map = []; // 0: Wall, 1: Path (Empty), 2: Dot, 3: Power Pellet
  let started = false;
  let paused = false;
  let gameInterval, speed = 250; 
  let gameOverFlag = false;
  let sfxMuted = false;
  let lastOverlayMsg = "";

  // --- Pac-Man Specific Functions ---
  
  /** Checks surrounding cells for walls to maintain dot density. */
  function getSurroundingWallCount(r, c, currentMap) {
      let wallCount = 0;
      // Check 3x3 area around the cell (r, c)
      for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue; // Skip the center cell
              const nr = r + dr;
              const nc = c + dc;

              if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < GRID_COLS) {
                  // Only count true, permanent walls
                  if (currentMap[nr][nc] === 0) {
                      wallCount++;
                  }
              }
          }
      }
      return wallCount;
  }

  /** Gets the count of PATH/DOT cells (non-wall) surrounding a cell. Used for wall cleanup. */
  function getSurroundingPathCount(r, c, currentMap) {
      let pathCount = 0;
      for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr;
              const nc = c + dc;

              if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < GRID_COLS) {
                  // Count path (1), dot (2), or pellet (3)
                  if (currentMap[nr][nc] !== 0) {
                      pathCount++;
                  }
              }
          }
      }
      return pathCount;
  }

  /** Generates a unique maze map with a guaranteed clear outer loop and usable inner maze. */
  function generateMap(currentLevel) {
    let newMap = [];
    
    // 1. Initialize map: all inner area to walls (0)
    for (let r = 0; r < GRID_ROWS; r++) {
        newMap[r] = new Array(GRID_COLS).fill(0); 
    }
    // Set ALL inner cells (excluding the perimeter) to wall (0)
    for (let r = 1; r < GRID_ROWS - 1; r++) {
        for (let c = 1; c < GRID_COLS - 1; c++) {
            newMap[r][c] = 0; 
        }
    }

    // CRITICAL FIX: Clear the outer path (row/col 1 to N-2) to be dots (2)
    for (let i = 1; i < GRID_COLS - 1; i++) {
        newMap[1][i] = 2; // Top
        newMap[GRID_ROWS - 2][i] = 2; // Bottom
    }
    for (let i = 1; i < GRID_ROWS - 1; i++) {
        newMap[i][1] = 2; // Left
        newMap[i][GRID_COLS - 2] = 2; // Right
    }

    // 2. Modified Recursive Backtracker Maze Generation
    // We carve the maze walls (0) into paths (1) starting INSIDE the clear loop.
    let visited = [];
    for(let r = 0; r < GRID_ROWS; r++) visited[r] = new Array(GRID_COLS).fill(0);
    
    let stack = [];
    let inner_min = 3;
    let inner_max_col = GRID_COLS - 4;
    let inner_max_row = GRID_ROWS - 4;

    // Start coordinates for carving must be odd and within the interior (3 to N-4)
    let startX = inner_min + (Math.floor(Math.random() * ((inner_max_col - inner_min) / 2 + 1)) * 2);
    let startY = inner_min + (Math.floor(Math.random() * ((inner_max_row - inner_min) / 2 + 1)) * 2);

    if (startX < inner_min) startX = inner_min;
    if (startY < inner_min) startY = inner_min;
    
    stack.push({x: startX, y: startY});
    visited[startY][startX] = 1;
    newMap[startY][startX] = 1; // Mark starting carving cell as path (1)

    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]]; // Move 2 steps

    while (stack.length > 0) {
        let {x: cx, y: cy} = stack[stack.length - 1];
        let unvisitedNeighbors = [];
        
        for (const [dx, dy] of directions) {
            const nx = cx + dx;
            const ny = cy + dy;
            // Carving bounds: [3..GRID_ROWS-4] for the ODD coordinate cells
            if (ny >= inner_min && ny <= inner_max_row && nx >= inner_min && nx <= inner_max_col && visited[ny][nx] === 0) {
                unvisitedNeighbors.push({x: nx, y: ny, dx: dx, dy: dy});
            }
        }
        
        if (unvisitedNeighbors.length > 0) {
            const next = unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];
            
            // Wall cell (0) is opened to a path (1) on the EVEN coordinate between them
            newMap[cy + next.dy / 2][cx + next.dx / 2] = 1; 
            
            stack.push(next);
            visited[next.y][next.x] = 1;
            newMap[next.y][next.x] = 1; // Mark new cell as empty path (1)
        } else {
            stack.pop();
        }
    }

    // --- POST GENERATION CLEANUP (FIXES DOUBLE WALLS) ---
    // If a wall cell has too few neighbors that are ALSO walls, it's a floating segment or part of a double wall.
    // We convert it to a path to join the maze.
    for (let r = 2; r < GRID_ROWS - 2; r++) {
        for (let c = 2; c < GRID_COLS - 2; c++) {
            if (newMap[r][c] === 0) { // Is this cell a Wall?
                const pathCount = getSurroundingPathCount(r, c, newMap);
                
                // If it has 5 or more path/dot neighbors, it's essentially a single floating wall or a corner
                // surrounded by paths. This ensures the walls are not thicker than 1 block.
                if (pathCount >= 5) { // 5 paths/dots means 3 or fewer walls, likely a double wall error
                   newMap[r][c] = 1; // Force open
                }
            }
        }
    }
    // -----------------------------------------------------


    // 3. Finalize: Connect the inner maze to the outer loop and place dots/pellets.

    // A. Fill all carved inner paths (1) with dots (2).
    for (let r = 2; r < GRID_ROWS - 2; r++) {
        for (let c = 2; c < GRID_COLS - 2; c++) {
            if (newMap[r][c] === 1) {
                newMap[r][c] = 2; // Inner path cells get dots
            }
        }
    }
    
    // B. Create connection gates (8 openings)
    const connectionPoints = [];
    
    // Check potential wall cells that separate the inner maze from the outer loop (at r/c 2 and N-3)
    for (let c = 2; c < GRID_COLS - 2; c++) { // Check ALL columns (even and odd)
        if (newMap[2][c] === 0) connectionPoints.push({r: 2, c: c});
        if (newMap[GRID_ROWS - 3][c] === 0) connectionPoints.push({r: GRID_ROWS - 3, c: c});
    }
    for (let r = 2; r < GRID_ROWS - 2; r++) { // Check ALL rows
        if (newMap[r][2] === 0) connectionPoints.push({r: r, c: 2});
        if (newMap[r][GRID_COLS - 3] === 0) connectionPoints.push({r: r, c: GRID_COLS - 3});
    }
    
    // Randomly open 8 connection points
    connectionPoints.sort(() => 0.5 - Math.random());
    const numToOpen = Math.min(connectionPoints.length, 8); 

    for (let i = 0; i < numToOpen; i++) {
        // Open wall to dot (2)
        newMap[connectionPoints[i].r][connectionPoints[i].c] = 2; 
        
        // Also ensure the dot immediately next to it on the outer ring is a path (1) to improve flow
        if (connectionPoints[i].r === 2) newMap[1][connectionPoints[i].c] = 1;
        if (connectionPoints[i].r === GRID_ROWS - 3) newMap[GRID_ROWS - 2][connectionPoints[i].c] = 1;
        if (connectionPoints[i].c === 2) newMap[connectionPoints[i].r][1] = 1;
        if (connectionPoints[i].c === GRID_COLS - 3) newMap[connectionPoints[i].r][GRID_COLS - 2] = 1;
    }

    // C. ENFORCE DOT DENSITY RULE (Remove dots surrounded by too many walls)
    let dotRemoved = true;
    while(dotRemoved) {
        dotRemoved = false;
        for (let r = 1; r < GRID_ROWS - 1; r++) {
            for (let c = 1; c < GRID_COLS - 1; c++) {
                if (newMap[r][c] === 2) {
                    const wallCount = getSurroundingWallCount(r, c, newMap);
                    if (wallCount >= WALL_SURROUND_THRESHOLD) {
                        newMap[r][c] = 1; // Change back to empty path (1)
                        dotRemoved = true;
                    }
                }
            }
        }
    }

    // D. Place Power Pellets (3) and clear start zone.
    
    // Place Power Pellets (3) in the corners of the outer loop
    newMap[1][GRID_COLS - 2] = 3;
    newMap[GRID_ROWS - 2][1] = 3;
    newMap[GRID_ROWS - 2][GRID_COLS - 2] = 3;
    
    // Clear Bradman's start spot (1,1)
    newMap[bradman.y][bradman.x] = 1; // Bradman's spot (clear path - 1)
    
    return newMap;
  }

  /** Sets up the ghosts based on the current map. */
  function setupGhosts() {
    ghosts = [];
    const baseGhosts = 2;
    const maxGhosts = 6;
    const numGhosts = Math.min(baseGhosts + Math.floor((level - 1) / 2), maxGhosts); 
    const ghostSpeedFactor = 1 + (level * 0.1); 

    for (let i = 0; i < numGhosts; i++) {
        let gx, gy;
        // Place ghosts near the outer loop's corners (indices 1 or GRID_X-2)
        if (i % 2 === 0) { 
            gx = GRID_COLS - 2 - (i % 4); 
            gy = 1 + (i % 2); 
        } else { 
            gx = 1 + (i % 4);
            gy = GRID_ROWS - 2 - (i % 2);
        }
        
        // Ensure ghost starts on a path (not wall)
        while(map[gy] && map[gy][gx] === 0) {
            gx = Math.floor(Math.random() * (GRID_COLS - 2)) + 1;
            gy = Math.floor(Math.random() * (GRID_ROWS - 2)) + 1;
        }

        ghosts.push({
            x: gx,
            y: gy,
            speed: ghostSpeedFactor,
            emoji: GHOST_EMOJIS[i % GHOST_EMOJIS.length],
            scared: false,
            scaredTimer: 0,
            dx: 0, 
            dy: 0 
        });
    }
  }

  // --- Bradman Movement Logic (FIXED for instant reversal) ---
  
  function moveBradman() {
    // 1. Check if the NEXT (pending) move is valid.
    const newX_tentative = bradman.x + bradman.next_dx;
    const newY_tentative = bradman.y + bradman.next_dy;
    
    if (newY_tentative >= 0 && newY_tentative < GRID_ROWS && 
        newX_tentative >= 0 && newX_tentative < GRID_COLS &&
        map[newY_tentative][newX_tentative] !== 0) 
    {
        // If the pending move is valid, commit it to the current direction
        // This is the core fix: it allows 180-degree turns instantly if the path is clear.
        bradman.dx = bradman.next_dx;
        bradman.dy = bradman.next_dy;
    }

    // 2. Execute the CURRENT direction move.
    const targetX = bradman.x + bradman.dx;
    const targetY = bradman.y + bradman.dy;

    if (targetY >= 0 && targetY < GRID_ROWS && 
        targetX >= 0 && targetX < GRID_COLS &&
        map[targetY][targetX] !== 0) 
    {
        bradman.x = targetX;
        bradman.y = targetY;
        return true;
    }
    // Stop movement if blocked
    bradman.dx = 0;
    bradman.dy = 0;
    return false;
  }
  
  function moveGhosts() {
    ghosts.forEach(ghost => {
        if (Math.random() > (1 / ghost.speed)) return;
        
        const dx_target = Math.sign(bradman.x - ghost.x);
        const dy_target = Math.sign(bradman.y - ghost.y);

        let targetX_dir = dx_target;
        let targetY_dir = dy_target;

        if (ghost.scared) {
            targetX_dir *= -1;
            targetY_dir *= -1;
        }
        
        let potentialDirs = [];

        if (targetX_dir !== 0 && map[ghost.y] && map[ghost.y][ghost.x + targetX_dir] !== 0) {
            potentialDirs.push({x: targetX_dir, y: 0});
        }
        if (targetY_dir !== 0 && map[ghost.y + targetY_dir] && map[ghost.y + targetY_dir][ghost.x] !== 0) {
            potentialDirs.push({x: 0, y: targetY_dir});
        }
        
        const perpendiculars = [
            {x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}
        ].filter(dir => 
            (dir.x !== -ghost.dx || dir.x === 0) && 
            (dir.y !== -ghost.dy || dir.y === 0) &&
            map[ghost.y + dir.y] && map[ghost.y + dir.y][ghost.x + dir.x] !== 0
        );

        const allValidMoves = [...potentialDirs, ...perpendiculars]
                                .filter((v, i, a) => a.findIndex(t => (t.x === v.x && t.y === v.y)) === i)
                                .sort(() => Math.random() - 0.5); 
        
        if (allValidMoves.length > 0) {
            const move = allValidMoves[0];
            ghost.x += move.x;
            ghost.y += move.y;
            ghost.dx = move.x;
            ghost.dy = move.y;
        }
    });
  }

  function BradmanGameLoop() {
    if (!started || gameOverFlag || paused) return;

    moveBradman();

    moveGhosts(); 
    ghosts.forEach(ghost => {
        if (ghost.scaredTimer > 0) {
            ghost.scaredTimer--;
            if (ghost.scaredTimer === 0) ghost.scared = false;
        }
    });

    let tileType = map[bradman.y][bradman.x];
    if (tileType === 2) {
        map[bradman.y][bradman.x] = 1; // Clear dot
        score += 10;
    } else if (tileType === 3) { // Power Pellet
        map[bradman.y][bradman.x] = 1; // Clear pellet
        score += 50;
        ghosts.forEach(g => {
            g.scared = true;
            g.scaredTimer = 200; // ~20 seconds
        });
    }

    ghosts.forEach((ghost) => {
        if (bradman.x === ghost.x && bradman.y === ghost.y) {
            if (ghost.scared) {
                score += 200;
                ghost.x = GRID_COLS - 2;
                ghost.y = 1;
                ghost.scared = false;
                ghost.scaredTimer = 0;
            } else {
                if (!sfxMuted) { crashSound.currentTime = 0; crashSound.play(); }
                gameOver();
                return;
            }
        }
    });
    
    let remainingDots = map.flat().filter(t => t === 2 || t === 3).length;
    if (remainingDots === 0) {
        levelUp();
        return;
    }

    updateHud();
    draw();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.font = `${TILE_SIZE}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const screenX = c * TILE_SIZE;
            const screenY = r * TILE_SIZE;
            
            ctx.save();
            if (map[r][c] === 0) { // Wall
                ctx.fillText(WALL_EMOJI, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2);
            } else if (map[r][c] === 2) { // Dot
                ctx.font = `${TILE_SIZE * 0.7}px sans-serif`;
                ctx.fillText(DOT_EMOJI, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2);
            } else if (map[r][c] === 3) { // Power Pellet
                ctx.font = `${TILE_SIZE}px sans-serif`;
                ctx.globalAlpha = Math.abs(Math.sin(Date.now() / 150)); 
                ctx.fillText(DOT_EMOJI, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2);
            }
            ctx.restore();
        }
    }

    ctx.font = `${TILE_SIZE}px sans-serif`;
    ctx.fillText(BRADMAN_EMOJI, 
                 (bradman.x + 0.5) * TILE_SIZE, 
                 (bradman.y + 0.5) * TILE_SIZE);

    ghosts.forEach(ghost => {
        let emoji = ghost.emoji;
        if (ghost.scared) {
            emoji = 'üò®'; 
            if (ghost.scaredTimer < 50 && (Math.floor(Date.now() / 150) % 2 === 0)) {
                emoji = ' RUN! '; 
                ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
            } else {
                 ctx.font = `${TILE_SIZE}px sans-serif`;
            }
        } else {
            ctx.font = `${TILE_SIZE}px sans-serif`;
        }

        ctx.fillText(emoji, 
                     (ghost.x + 0.5) * TILE_SIZE, 
                     (ghost.y + 0.5) * TILE_SIZE);
    });
  }

  function levelUp() {
    alert(`Level ${level} Complete! Getting harder now...`);
    level++;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('bradman_highscore', highScore);
    }
    
    bradman.x = 1;
    bradman.y = 1;
    bradman.dx = 0;
    bradman.dy = 0;
    bradman.next_dx = 0;
    bradman.next_dy = 0;
    
    map = generateMap(level);
    setupGhosts();
    updateHud();
  }

  function resetGame() {
    try {
        level = 1;
        score = 0;
        bradman = { x: 1, y: 1, dx: 0, dy: 0, next_dx: 0, next_dy: 0 };
        gameOverFlag = false;
        paused = false; 
        started = false;

        updateHud();
        gameStatusLine.style.display = "none";
        
        if (isTouchDevice()) {
            statusBarRow1.style.display = "flex";
            statusBarRow2.style.display = "flex";
        } else {
            statusBarCombined.style.display = "flex";
        }
        hideOverlay();
        clearInterval(gameInterval);
        
        map = generateMap(level);
        setupGhosts(); 
        
        const currentSpeedOption = getEl("speedSelect").value;
        speed = Number(currentSpeedOption);
        gameInterval = setInterval(BradmanGameLoop, speed);
        
        draw();
        setTimeout(() => canvas.focus(), 100);
    } catch (e) {
        console.error("Game failed to initialize:", e);
        alert("Game failed to load. Check console for details.");
    }
  }

  function gameOver() {
    clearInterval(gameInterval);
    gameOverFlag = true;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('bradman_highscore', highScore);
    }
    
    finalScoreSpan.textContent = `Score: ${score} (Level ${level})`;
    updateHud();
    
    if (isTouchDevice()) {
      statusBarRow1.style.display = "none";
      statusBarRow2.style.display = "none";
    } else {
      statusBarCombined.style.display = "none";
    }
    gameStatusLine.style.display = "flex";
    showOverlay("GAME OVER");
    setTimeout(hideOverlay, 1800);
  }
  
  // --- UI/Control Handlers (Retained from base template) ---

  function updateHud() {
    const scoreVal = "Score: " + score;
    const levelVal = "Level: " + level;
    const highVal = "High Score: " + highScore;

    getEl("scoreDisplay").textContent = scoreVal;
    getEl("levelDisplay").textContent = levelVal;
    getEl("highScoreDisplay").textContent = highVal;
  }

  function showOverlay(msg) {
    overlay.textContent = msg;
    overlay.style.display = "block";
    lastOverlayMsg = msg;
  }
  function hideOverlay() {
    overlay.style.display = "none";
    lastOverlayMsg = "";
  }
  
  function setDirection(newDir) {
    // FIX: Set the next_dx/dy instantly for full Pac-Man responsiveness (including 180 turns)
    bradman.next_dx = newDir.x;
    bradman.next_dy = newDir.y;
    started = true;
    if (!paused && !gameOverFlag) hideOverlay();
  }
  
  bindButton(getEl("loginBtn"), () => { loginPopup.style.display = "block"; });
  document.getElementById("closeLoginPopup").onclick = () => { loginPopup.style.display = "none"; }
  window.addEventListener('keydown', function(e) {
    if (e.key === "Escape") loginPopup.style.display = "none";
  });
  
  document.addEventListener("keydown", e => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(e.key)) {
      e.preventDefault(); 
      if (e.key === "ArrowUp" || e.key === "w") setDirection({ x: 0, y: -1 });
      if (e.key === "ArrowDown" || e.key === "s") setDirection({ x: 0, y: 1 });
      if (e.key === "ArrowLeft" || e.key === "a") setDirection({ x: -1, y: 0 });
      if (e.key === "ArrowRight" || e.key === "d") setDirection({ x: 1, y: 0 });
      canvas.focus();
    }
    if (e.key.toLowerCase() === "p") {
      togglePause();
    }
    if (gameOverFlag && e.key === "Enter") {
      resetGame();
    }
  });

  let touchStartX, touchStartY;
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  });
  canvas.addEventListener('touchend', function(e) {
    if (touchStartX === undefined || touchStartY === undefined) return;
    let dx = e.changedTouches[0].clientX - touchStartX;
    let dy = e.changedTouches[0].clientY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 20) setDirection({ x: 1, y: 0 });
      if (dx < -20) setDirection({ x: -1, y: 0 });
    } else {
      if (dy > 20) setDirection({ x: 0, y: 1 });
      if (dy < -20) setDirection({ x: 0, y: -1 });
    }
    touchStartX = touchStartY = undefined;
  });

  const upBtn = document.getElementById("upBtn");
  const downBtn = document.getElementById("downBtn");
  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");
  if(upBtn) upBtn.onclick = e => setDirection({ x: 0, y: -1 });
  if(downBtn) downBtn.onclick = e => setDirection({ x: 0, y: 1 });
  if(leftBtn) leftBtn.onclick = e => setDirection({ x: -1, y: 0 });
  if(rightBtn) rightBtn.onclick = e => setDirection({ x: 1, y: 0 });
  
  function bindButton(btn, clickFn) {
    if (btn) btn.onclick = clickFn;
  }
  
  function togglePause() {
    if (gameOverFlag) return;
    let pb = getEl("pauseBtn");
    pb.innerHTML = paused ? "‚è∏Ô∏è" : "‚ñ∂Ô∏è";
    pb.setAttribute("aria-pressed", paused ? "false" : "true");
    paused = !paused;
    if (paused) {
      showOverlay("PAUSED");
      clearInterval(gameInterval); 
    } else {
      hideOverlay();
      gameInterval = setInterval(BradmanGameLoop, speed); 
    }
  }
  bindButton(getEl("pauseBtn"), togglePause);
  document.getElementById("restartBtn").onclick = resetGame;
  
  function toggleMute() {
    sfxMuted = !sfxMuted;
    const btns = [document.getElementById("muteBtn"), document.getElementById("muteBtnTouch")].filter(Boolean);
    btns.forEach(btn => btn.textContent = sfxMuted ? "üîá" : "üîä");
  }
  bindButton(getEl("muteBtn"), toggleMute);
  
  function changeSpeed(selectEl) {
    speed = Number(selectEl.value);
    clearInterval(gameInterval);
    if (!paused && !gameOverFlag) {
      gameInterval = setInterval(BradmanGameLoop, speed);
    }
    document.getElementById("speedSelect").value = speed + '';
    if(document.getElementById("speedSelectTouch"))
        document.getElementById("speedSelectTouch").value = speed + '';
  }
  if(document.getElementById("speedSelect")) document.getElementById("speedSelect").onchange = (e) => changeSpeed(e.target);
  if(document.getElementById("speedSelectTouch")) document.getElementById("speedSelectTouch").onchange = (e) => changeSpeed(e.target);

  function toggleRadio() {
    const btns = [document.getElementById("toggleRadio"), document.getElementById("toggleRadioTouch")].filter(Boolean);
    if (radio.paused) {
      radio.play();
      btns.forEach(btn => btn.textContent = "Radio OFF");
    } else {
      radio.pause();
      btns.forEach(btn => btn.textContent = "Radio ON");
    }
  }
  bindButton(getEl("toggleRadio"), toggleRadio);
  
  // Initial setup and start
  canvas.onclick = () => canvas.focus();
  function resizeCanvas() {
    const size = Math.min(window.innerWidth, window.innerHeight) * 0.9;
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();
  
  window.addEventListener('focus', () => {
    if (paused && lastOverlayMsg !== "PAUSED") showOverlay("PAUSED");
  });
  
  updateHud();
  resetGame();
}
</script>
</body>
</html>
